<title>WebGL最简单的贴图 - www.web-tinker.com</title>
<canvas id="canvas" width="600" height="400"></canvas>
<script id="vs_s" type="text/plain">
attribute vec3 po;
attribute vec2 mp; //贴图坐标
uniform mat4 pro;
uniform mat4 rot;
uniform mat4 mov;
varying vec2 mp_v; //贴图坐标管道
void main(){
  mp_v=mp;
  gl_Position=pro*mov*rot*vec4(po,1.0);
}
</script>
<script id="fs_s" type="text/plain">
varying lowp vec2 mp_v; //贴图坐标管道
uniform sampler2D tex; //图片数据对象
void main(){
  //调用texture2D函数，取出图片数据对象在某个坐标点的颜色
  gl_FragColor=texture2D(tex,mp_v);
}
</script>
<script>
var webgl,program,fs,vs,tmp,i,j;

//获取WebGL对象，并制作着色器程序
webgl=canvas.getContext("experimental-webgl");
program=webgl.createProgram();
vs=webgl.createShader(webgl.VERTEX_SHADER);
fs=webgl.createShader(webgl.FRAGMENT_SHADER);
webgl.shaderSource(vs,vs_s.textContent);
webgl.shaderSource(fs,fs_s.textContent);
webgl.compileShader(vs);
webgl.compileShader(fs);
webgl.attachShader(program,vs);
webgl.attachShader(program,fs);
webgl.linkProgram(program);
webgl.useProgram(program);

//数据源相关
var po,mp,dat,buf;

//获取接口位置，并开启数组模式
po=webgl.getAttribLocation(program,"po");
mp=webgl.getAttribLocation(program,"mp");
webgl.enableVertexAttribArray(po);
webgl.enableVertexAttribArray(mp);

//指定顶点坐标的数据源
dat=new Float32Array(tmp=[
  -1,-1,-1, -1,1,-1,  -1,1,1, -1,-1,1,  //左面
  1,-1,-1,  1,1,-1,   1,1,1,  1,-1,1,   //右面
  -1,1,-1,  1,1,-1,   1,1,1,  -1,1,1,   //上面
  -1,-1,-1, 1,-1,-1,  1,-1,1, -1,-1,1,  //下面
  -1,-1,1,  1,-1,1,   1,1,1,  -1,1,1,   //前面
  -1,-1,-1, 1,-1,-1,  1,1,-1, -1,1,-1   //后面
]);
buf=webgl.createBuffer();
webgl.bindBuffer(webgl.ARRAY_BUFFER,buf);
webgl.bufferData(webgl.ARRAY_BUFFER,dat,webgl.STATIC_DRAW);
webgl.vertexAttribPointer(po,3,webgl.FLOAT,false,0,0);

//指定贴图位置数据源
for(dat=[],i=0;i<tmp.length;i+=3)for(j=0;j<3;j++)
  if(j!=(i/24|0))dat.push((tmp[i+j]+1)/2);
dat=new Float32Array(dat);
buf=webgl.createBuffer();
webgl.bindBuffer(webgl.ARRAY_BUFFER,buf);
webgl.bufferData(webgl.ARRAY_BUFFER,dat,webgl.STATIC_DRAW);
webgl.vertexAttribPointer(mp,2,webgl.FLOAT,false,0,0);

//uniform参数相关
var pro,rot,mov,tex;

//获取uniform们的句柄
pro=webgl.getUniformLocation(program,"pro");
rot=webgl.getUniformLocation(program,"rot");
mov=webgl.getUniformLocation(program,"mov");
tex=webgl.getUniformLocation(program,"tex");

//设置投射矩阵
webgl.uniformMatrix4fv(
  pro,false,(function(a,r,n,f){
    //参数分别是：视角、区域宽高比、近平面、远平面
    a=1/Math.tan(a*Math.PI/360);
    return [
      a/r,0,0,0, 0,a,0,0, 0,0,-(f+n)/(f-n),-1, 0,0,-2*f*n/(f-n),0
    ];
  })(45,canvas.width/canvas.height,1,100)
);

//设置移动矩阵（向z方向移动-10）
webgl.uniformMatrix4fv(
  mov,false,[1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-5,1]
);

//设置图片数据
var img;
img=new Image;
img.src="uv_grid_512.jpg";
img.onload=function(){
  //创建贴图（材质）对象句柄
  var texture=webgl.createTexture();
  //指定当前使用的贴图序号
  webgl.activeTexture(webgl.TEXTURE0);
  //设置为当前工作的贴图对象
  webgl.bindTexture(webgl.TEXTURE_2D,texture);
  //设置图片数据
  webgl.texImage2D(
    webgl.TEXTURE_2D,0,webgl.RGBA,webgl.RGBA,webgl.UNSIGNED_BYTE,img
  );
  //设置贴图参数
  webgl.texParameteri(
    webgl.TEXTURE_2D,webgl.TEXTURE_MIN_FILTER,webgl.NEAREST
  );
  //把预置缓冲区的序号传入uniform
  webgl.uniform1i(tex,0);
  //开始绘制（这个是自定义函数，在后面定义的）
  draw();
};

//构造索引
for(dat=[],i=0;i<24;i+=4)dat.push(i+0,i+1,i+3,i+3,i+2,i+1);
dat=new Uint16Array(dat);
buf=webgl.createBuffer();
webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER,buf);
webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER,dat,webgl.STATIC_DRAW);

//深度测试
webgl.enable(webgl.DEPTH_TEST);

//绘制过程
function draw(){
  var a=0;
  setInterval(function(){
    //设置旋转矩阵
    a-=0.02;
    var s=Math.sin(a),c=Math.cos(a);
    webgl.uniformMatrix4fv(
      rot,false,[c*c,-s,s*c,0, s*c,c,s*s,0, -s,0,c,0, 0,0,0,1]
    );
    //绘制
    webgl.drawElements(webgl.TRIANGLES,36,webgl.UNSIGNED_SHORT,0);
  },16);
};
</script>